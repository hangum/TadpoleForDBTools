<?xml version="1.0" encoding="UTF-8" ?>
<!--
  Copyright (c) 2013 hangum.
  All rights reserved. This program and the accompanying materials
  are made available under the terms of the GNU Lesser Public License v2.1
  which accompanies this distribution, and is available at
  http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  
  Contributors:
      hangum - initial API and implementation
-->
<!DOCTYPE sqlMap      
    PUBLIC "-//ibatis.apache.org//DTD SQL Map 2.0//EN"      
    "http://ibatis.apache.org/dtd/sql-map-2.dtd">

<!-- 
	PostgreSQL 9.1 버전으로 초기 작업을 시작했습니다.
	이전 버전으로는 테스트 못해봤어요.  - 12.08.07
	
	@author hangum	
 -->
<sqlMap namespace="POSTGRESQL_query">

<!--
	database connection test 
 -->
<select id="connectionCheck" resultClass="java.lang.String" parameterClass="java.lang.String">
	SELECT version()
</select>

<!-- 
	database schema
 -->
<select id="getSchemas" resultClass="java.util.HashMap">
	SELECT CASE WHEN nspname LIKE E'pg\\_temp\\_%' THEN 1
	            WHEN (nspname LIKE E'pg\\_%') THEN 0
	            ELSE 3 END AS nsptyp,
	       nsp.nspname as schema, 
	       nsp.oid, 
	       pg_get_userbyid(nspowner) AS namespaceowner, 
	       nspacl, 
	       description, 
	       has_schema_privilege(nsp.oid, 'CREATE') as cancreate,
	    (SELECT array_agg(label) FROM pg_seclabels sl1 WHERE sl1.objoid=nsp.oid) AS labels,
	    (SELECT array_agg(provider) FROM pg_seclabels sl2 WHERE sl2.objoid=nsp.oid) AS providers
	FROM pg_namespace nsp
	  LEFT OUTER JOIN pg_description des ON (des.objoid=nsp.oid AND des.classoid='pg_namespace'::regclass)
	WHERE 
	    NOT (
	        (nspname = 'pg_catalog' AND EXISTS 
	            (SELECT 1 FROM pg_class WHERE relname = 'pg_class' AND relnamespace = nsp.oid LIMIT 1)) OR
	        (nspname = 'pgagent' AND EXISTS 
	            (SELECT 1 FROM pg_class WHERE relname = 'pga_job' AND relnamespace = nsp.oid LIMIT 1)) OR
	        (nspname = 'information_schema' AND EXISTS 
	            (SELECT 1 FROM pg_class WHERE relname = 'tables' AND relnamespace = nsp.oid LIMIT 1)) OR
	        (nspname LIKE '_%' AND EXISTS 
	            (SELECT 1 FROM pg_proc WHERE proname='slonyversion' AND pronamespace = nsp.oid LIMIT 1))
	    )  
	    AND nspname NOT LIKE E'pg\\_temp\\_%'
	    AND nspname NOT LIKE E'pg\\_toast_temp\\_%' 
	    AND nspname NOT LIKE 'pg_toast'
	ORDER BY 1, nspname
</select>

<!-- 
	table 이름
	테이블 코멘트 부분 처리를 못해서... 
	AND relname ~ '^(emp)$' 부분에 AND relname ~ '^(a.table_name)$' 가 들어가야 합니다. 
 -->
 <select id="tableListOnlyName" resultClass="com.hangum.tadpole.engine.query.dao.mysql.TableDAO" parameterClass="java.lang.String">
SELECT
	b.table_schema || '.' || relname as "name"
FROM pg_catalog.pg_class a,
    information_schema.tables b
WHERE 1=1
    AND a.relkind IN ('r','')
    AND b.table_schema NOT IN ('pg_catalog', 'information_schema')
    AND b.table_type = 'BASE TABLE'
    AND a.relname = b.table_name
GROUP BY name
ORDER BY name
</select>
<select id="tableList" resultClass="com.hangum.tadpole.engine.query.dao.mysql.TableDAO" parameterClass="java.lang.String">
SELECT
	b.table_schema as "schema_name"
    ,relname as "realname"
   	,relname as "name"
    ,pg_catalog.obj_description(oid,'pg_class') as "comment"
FROM pg_catalog.pg_class a,
    information_schema.tables b
WHERE 1=1
    AND a.relkind IN ('r','')
    AND b.table_schema NOT IN ('pg_catalog', 'information_schema')
    AND b.table_type = 'BASE TABLE'
    AND a.relname = b.table_name
GROUP BY schema_name, realname, name, comment
ORDER BY name
</select>

<select id="table" resultClass="com.hangum.tadpole.engine.query.dao.mysql.TableDAO" parameterClass="java.util.HashMap">
 SELECT
 	table_schema as "schema_name"
    ,relname as "name"
    ,pg_catalog.obj_description(oid,'pg_class') as "comment"
  FROM pg_catalog.pg_class ‌
  WHERE 1 = 1 
    AND relkind IN ('r','')
    AND relname IN (
      SELECT a.table_name
        FROM information_schema.tables a
        WHERE a.table_schema NOT IN ('pg_catalog', 'information_schema') 
          AND a.table_type = 'BASE TABLE' )
    AND relname = #name#
  ORDER BY name
</select>

<!-- 
	특정 table의 table이나 view 컬럼 정보
	
	컬럼 설명
	Field			: 컬럼 명
	Type			: 컬럼 타입
	Null			: Null 유무 (예: YES,NO)
	Key				: primary key, foreign key(예: PK, FK)
	Default			: 기본값
	Extra			: 특수컬럼(예: auto_increment)

	PostgreSQL System function
	col_description(table_oid, column_number)	text	get comment for a table column
	obj_description(object_oid, catalog_name)	text	get comment for a database object
	
 -->
<select id="tableColumnList" resultClass="com.hangum.tadpole.engine.query.dao.mysql.TableColumnDAO" parameterClass="java.util.HashMap">
	SELECT a.column_name AS "FIELD",
       a.data_type  "TYPE",
       a.is_nullable AS "NULL",
       a.column_default as "Default"  ,
       (SELECT
  			case when max(tc.constraint_type) != min(tc.constraint_type)
  			     then max(tc.constraint_type) || ',' || min(tc.constraint_type)
                 else max(tc.constraint_type) end
			FROM 
   				 information_schema.table_constraints AS tc 
  				  JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name
			WHERE tc.table_name = #table# 
			AND kcu.column_name = a.column_name) as "key",
		(
		SELECT 
		    pg_catalog.col_description(attrelid, attnum)
		FROM 
		    pg_catalog.pg_attribute
		WHERE 
		    attrelid = (select a.oid 
		                    from pg_catalog.pg_class a
		                        ,pg_catalog.pg_namespace b
		                    where a.relname = #table#
		                    and b.nspname =  #schema#
                            and a.relnamespace = b.oid) AND 
		    attname= a.column_name AND 
		    attnum > 0 AND 
		    NOT attisdropped
		)	as "comment"			
    FROM information_schema.columns a
    WHERE a.table_name = #table#
    	AND a.table_schema = #schema#
	ORDER BY a.ordinal_position
</select>

<!-- 
	테이블간의 관계 목록 정보를 얻습니다.
	erd 그릴때 관계 목록을 보여주기 위한 목적입니다.
 -->
<select id="referencedTableList"  resultClass="com.hangum.tadpole.engine.query.dao.mysql.ReferencedTableDAO" parameterClass="java.lang.String">
 SELECT
    tc.constraint_name, 
    tc.table_name, 
    kcu.column_name, 
    ccu.table_name AS referenced_table_name,
    ccu.column_name AS referenced_column_name 
FROM 
    information_schema.table_constraints AS tc 
    JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name
    JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name
WHERE tc.table_name in ($tables$)
</select>

<!-- 
	모든 관계 테이블 목록을 가져옵니다.
 -->
<select id="referencedTableListALL"  resultClass="com.hangum.tadpole.engine.query.dao.mysql.ReferencedTableDAO" >
SELECT
    tc.constraint_name, 
    tc.table_name, 
    kcu.column_name, 
    ccu.table_name AS referenced_table_name,
    ccu.column_name AS referenced_column_name 
FROM 
    information_schema.table_constraints AS tc 
    JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name
    JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name
</select>
	
<!-- 
	db의 view 정보
	
	컬럼 설명
	oebjt_name		: view 이름
 -->
<select id="viewList" resultClass="com.hangum.tadpole.engine.query.dao.mysql.TableDAO" parameterClass="java.lang.String">
	SELECT table_name, table_schema as schema_name
	FROM information_schema.tables 
	WHERE  
		    table_type = 'VIEW'
		AND table_schema NOT IN ('pg_catalog', 'information_schema')
	ORDER BY table_name
</select>
	
<!-- 
	index 상세 내역
	아래 내역은 mysql db의 특성에 맟춘것으로 각 디비의 특성에 맟춥니다.
	
	컬럼 설명
	table_name			:  	테이블 명
    index_name			:	인덱스 명
    column_name			:	컬럼 명
    column_position		: 
    column_length		:
    char_length			:
    descend				:	
    uniqueness			:
    table_owner			:
    constraint_type		:
    status				:
    #table_schema# AS table_schema
 -->
 <select id="indexList" resultClass="com.hangum.tadpole.engine.query.dao.mysql.InformationSchemaDAO" parameterClass="java.util.Map">
	select
		 n.nspname as "schema_name",
	     t.relname  as "table_name",
	     c.relname  as "index_name"
	from
	          pg_catalog.pg_class c
	     join pg_catalog.pg_namespace n on n.oid        = c.relnamespace
	     join pg_catalog.pg_index i     on i.indexrelid = c.oid
	     join pg_catalog.pg_class t     on i.indrelid   = t.oid
	where
	        c.relkind = 'i'
	    and n.nspname not in ('pg_catalog', 'pg_toast')
	    and pg_catalog.pg_table_is_visible(c.oid)
	    and lower(t.relname) = lower(#table_name#) 
</select>
<!-- 
	index의 디테일 정보
	
	and t.relkind = 'r'
	and ix.indisunique = 'true'
	and ix.indisprimary = 'false'
	
 -->
 <select id="indexDetailList" resultClass="com.hangum.tadpole.engine.query.dao.mysql.InformationSchemaDAO" parameterClass="java.util.Map">
	select
	t.relname as table_name,
	i.relname as index_name,
	a.attname as column_name,
	row_number() over() as seq_in_index,
	0 as column_length,
	0 as char_length,
	'' as "comment",
	ix.indisunique as uniqueness,
	'' as table_owner,
	'' as table_schema,
	ix.indisprimary,
	ix.indoption
	from
	pg_class t,
	pg_class i,
	pg_index ix,
	pg_attribute a
	where
	t.oid = ix.indrelid
	and i.oid = ix.indexrelid
	and a.attrelid = t.oid
	and a.attnum = ANY(ix.indkey)
	and t.relname = #table_name#
	and i.relname = #index_name#
	order by t.relname, i.relname
</select>

<!-- 
	procedure 상세 내역
	아래 내역은 mysql db의 특성에 맟춘것으로 각 디비의 특성에 맟춥니다.
	
	컬럼 설명
	db				:	db 명
	name			:	procedure 명
	type			:	procedure type
	definer			:	procedure 정의 자
	modified		:	수정일시
	created			:	생성일시
	security_type	:	예를 들어 (DEFINER)
	comment			:
	character_set_client	:	예를 들어 (utf8)
	collation_connection	:	에를 들어 (utf8_general_ci)
	database				:
	collation				:
	
	prorettype = 2278 : procedure return type void
	prorettype = 2279 : procedure return type trigger
 -->
<select id="procedureList" resultClass="com.hangum.tadpole.engine.query.dao.mysql.ProcedureFunctionDAO" parameterClass="java.lang.String">
	SELECT  
			nspname "schema_name",
			proname "name", 
			'PROCEDURE' as type 
	FROM    pg_catalog.pg_namespace n 
	JOIN    pg_catalog.pg_proc p 
	ON      pronamespace = n.oid 
	WHERE    
			nspname NOT IN ('pg_catalog', 'information_schema')
		AND pronargs = 0
		AND prorettype = 2278; 
</select>

<!-- 
	function 상세 내역
	아래 내역은 mysql db의 특성에 맟춘것으로 각 디비의 특성에 맟춥니다.
	
	컬럼 설명
	db				:	db 명
	name			:	procedure 명
	type			:	procedure type
	definer			:	procedure 정의 자
	modified		:	수정일시
	created			:	생성일시
	security_type	:	예를 들어 (DEFINER)
	comment			:
	character_set_client	:	예를 들어 (utf8)
	collation_connection	:	에를 들어 (utf8_general_ci)
	database				:
	collation				:
 -->
<select id="functionList" resultClass="com.hangum.tadpole.engine.query.dao.mysql.ProcedureFunctionDAO" parameterClass="java.lang.String">
	SELECT  nspname "schema_name",
			proname "name", 'FUNCTION' as type 
	FROM    pg_catalog.pg_namespace n 
	JOIN    pg_catalog.pg_proc p 
	ON      pronamespace = n.oid 
	WHERE   
			nspname NOT IN ('pg_catalog', 'information_schema')
		AND pronargs > 0; 
</select>

<!-- <select id="getFunctionScript" resultClass="java.lang.String" parameterClass="java.lang.String">
	SELECT  prosrc
	FROM    pg_catalog.pg_namespace n
	JOIN    pg_catalog.pg_proc p
	ON      pronamespace = n.oid
	WHERE   nspname = 'public'
	and proname like '$object_name$';
</select> -->

<!-- 
	show 내역
	아래 내역은 mysql db의 특성에 맟춘것으로 각 디비의 특성에 맟춥니다.
	
	컬럼 설명
	trigger			: trigger name	
	event			: event
	table			: table name
	statement		:
	timing			:
	created			:
	sql_mode		:
	definer			:
	character_set_client	:	
	collation_connection	:
	database				:
	collation				:
 -->
<select id="triggerAllList" resultClass="com.hangum.tadpole.engine.query.dao.mysql.TriggerDAO" parameterClass="java.lang.String">
<![CDATA[
 SELECT 
    (current_database())::information_schema.sql_identifier AS Database,
    (t.tgname)::information_schema.sql_identifier AS trigger,
    (em.text)::information_schema.character_data AS Event,
    (current_database())::information_schema.sql_identifier AS Definer,
    (c.relname)::information_schema.sql_identifier AS Table_name,
    (CASE WHEN pg_has_role(c.relowner, 'USAGE'::text) THEN ( 
        SELECT rm.m[1] AS m
        FROM regexp_matches(pg_get_triggerdef(t.oid), '.{35,} WHEN ((.+)) EXECUTE PROCEDURE'::text) rm(m) LIMIT 1)
    ELSE NULL::text END)::information_schema.character_data AS action_condition,
    ("substring"(pg_get_triggerdef(t.oid), ("position"("substring"(pg_get_triggerdef(t.oid), 48), 'EXECUTE PROCEDURE'::text) + 47)))::information_schema.character_data AS Statement,
    (CASE ((t.tgtype)::integer & 1) WHEN 1 THEN 'ROW'::text ELSE 'STATEMENT'::text END)::information_schema.character_data ||' '||
    (CASE ((t.tgtype)::integer & 66)
     WHEN 2 THEN 'BEFORE'::text
     WHEN 64 THEN 'INSTEAD OF'::text
     ELSE 'AFTER'::text END)::information_schema.character_data AS Timing,
    (NULL::timestamp with time zone)::information_schema.time_stamp AS created,
    (case when t.tgenabled = 'O' then 'VALID' else 'INVALID' end) as Status
   FROM pg_namespace n,
    pg_class c,
    pg_trigger t,
    ( VALUES (4,'INSERT'::text), (8,'DELETE'::text), (16,'UPDATE'::text)) em(num, text)
  WHERE ((((((n.oid = c.relnamespace) AND (c.oid = t.tgrelid)) 
AND (((t.tgtype)::integer & em.num) <> 0)) 
AND (NOT t.tgisinternal)) 
AND (NOT pg_is_other_temp_schema(n.oid))) 
AND ((pg_has_role(c.relowner, 'USAGE'::text) 
 OR has_table_privilege(c.oid, 'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text)) 
 OR has_any_column_privilege(c.oid, 'INSERT, UPDATE, REFERENCES'::text)));
 ]]>
</select>
<select id="triggerList" resultClass="com.hangum.tadpole.engine.query.dao.mysql.TriggerDAO" parameterClass="java.util.Map">
<![CDATA[
 SELECT 
    (current_database())::information_schema.sql_identifier AS Database,
    (t.tgname)::information_schema.sql_identifier AS trigger,
    (em.text)::information_schema.character_data AS Event,
    (current_database())::information_schema.sql_identifier AS Definer,
    (c.relname)::information_schema.sql_identifier AS Table_name,
    (CASE WHEN pg_has_role(c.relowner, 'USAGE'::text) THEN ( 
        SELECT rm.m[1] AS m
        FROM regexp_matches(pg_get_triggerdef(t.oid), '.{35,} WHEN ((.+)) EXECUTE PROCEDURE'::text) rm(m) LIMIT 1)
    ELSE NULL::text END)::information_schema.character_data AS action_condition,
    ("substring"(pg_get_triggerdef(t.oid), ("position"("substring"(pg_get_triggerdef(t.oid), 48), 'EXECUTE PROCEDURE'::text) + 47)))::information_schema.character_data AS Statement,
    (CASE ((t.tgtype)::integer & 1) WHEN 1 THEN 'ROW'::text ELSE 'STATEMENT'::text END)::information_schema.character_data ||' '||
    (CASE ((t.tgtype)::integer & 66)
     WHEN 2 THEN 'BEFORE'::text
     WHEN 64 THEN 'INSTEAD OF'::text
     ELSE 'AFTER'::text END)::information_schema.character_data AS Timing,
    (NULL::timestamp with time zone)::information_schema.time_stamp AS created,
    (case when t.tgenabled = 'O' then 'VALID' else 'INVALID' end) as Status
   FROM pg_namespace n,
    pg_class c,
    pg_trigger t,
    ( VALUES (4,'INSERT'::text), (8,'DELETE'::text), (16,'UPDATE'::text)) em(num, text)
  WHERE ((((((n.oid = c.relnamespace) AND (c.oid = t.tgrelid)) 
AND (((t.tgtype)::integer & em.num) <> 0)) 
AND (NOT t.tgisinternal)) 
AND (NOT pg_is_other_temp_schema(n.oid))) 
AND lower(c.relname) = lower(#table_name#)
AND ((pg_has_role(c.relowner, 'USAGE'::text) 
 OR has_table_privilege(c.oid, 'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text)) 
 OR has_any_column_privilege(c.oid, 'INSERT, UPDATE, REFERENCES'::text)));
 ]]>
</select>

<!-- 
	enable 상태의 트리거 목록을 리턴한다.
 -->
<select id="triggerListInTable" resultClass="java.util.HashMap" parameterClass="java.lang.String">
<![CDATA[
SELECT 
     c.relname as Table_name 
    ,t.tgname as Trigger_name
    ,'ALTER TABLE ' || c.relname || ' DISABLE TRIGGER ' || t.tgname as Disable_Statement
    ,'ALTER TABLE ' || c.relname || ' ENABLE TRIGGER ' || t.tgname as Enable_Statement
FROM pg_class c 
  inner join pg_trigger t on c.oid = t.tgrelid
WHERE 1 = 1 
  AND NOT t.tgisinternal 
  AND lower(c.relname) = lower(#table_name#)
  AND t.tgenabled = 'O'
 ]]>
</select>

<!-- 
	table명을 받아서 pk 컬럼 목록을 리턴한다.
 -->
<select id="primarykeyListInTable" resultClass="java.util.HashMap" parameterClass="java.lang.String">
select 
    a.attname as column_name
    ,a.attnum as column_order
from pg_class t
    inner join pg_index ix on t.oid = ix.indrelid
    inner join pg_attribute a on a.attrelid = t.oid and a.attnum = ANY(ix.indkey)
where 1=1
  and lower(t.relname) = lower(#table_name#)
</select>

<!-- 
	table row count
 -->
<select id="tableRowCount" resultClass="java.lang.Integer" parameterClass="java.lang.String">
	SELECT count(*) FROM $table$ 
</select>

<!-- 
	table information
 -->
<select id="tableInformation" resultClass="java.util.HashMap" parameterClass="java.lang.String">
SELECT
    relname as "name"
    , relhasindex as has_index
    , relisshared as is_shared
    , relhaspkey as has_pk
    , relhastriggers as has_triggers
    , relhassubclass as has_subclass
    , relhasrules as has_rules
    , reloptions as options
    ,pg_catalog.obj_description(oid,'pg_class') as "comment"
  FROM pg_catalog.pg_class ‌
  WHERE 1 = 1 
    AND relkind IN ('r','')
    AND relname IN (
      SELECT a.table_name
        FROM information_schema.tables a
        WHERE a.table_schema = 'public' 
          AND a.table_type = 'BASE TABLE' )
  ORDER BY name
</select>

<!-- 
	column information
 -->
<select id="columnInformation" resultClass="com.hangum.tadpole.engine.query.dao.rdb.RDBInfomationforColumnDAO" parameterClass="java.lang.String">
	SELECT b.table_name
	  , (select  pg_catalog.obj_description(cl.oid,'pg_class')  from pg_catalog.pg_class cl where cl.relname = a.table_name  ) as table_comment
	  ,a.column_name
       ,a.data_type 
       ,a.is_nullable as nullable
       ,a.column_default as data_default
	    ,(SELECT 
		    pg_catalog.col_description(attrelid, attnum)
		FROM    pg_catalog.pg_attribute
		WHERE attrelid = (select oid from pg_catalog.pg_class  where relname = a.table_name  ) 
		AND attname= a.column_name 
		AND attnum > 0 
		AND NOT attisdropped )	as "column_comment"			
       ,(SELECT
  			case when max(tc.constraint_type) != min(tc.constraint_type)
  			     then max(tc.constraint_type) || ',' || min(tc.constraint_type)
                 else max(tc.constraint_type) end 
			FROM 
   				 information_schema.table_constraints AS tc 
  				  JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name
			WHERE tc.table_name = a.table_name
			AND kcu.column_name = a.column_name) as "key"
    FROM information_schema.columns a
    	inner join information_schema.tables b on b.table_name= a.table_name
    	where b.table_schema = 'public' 
    	and b.table_type = 'BASE TABLE'
	ORDER BY a.ordinal_position
</select>

<!-- 
	Table DDL Script
 -->
<select id="getTableScript" resultClass="java.util.HashMap" parameterClass="java.lang.String">

  SELECT 
            b.nspname as OWNER,
            b.relname as TABLE_NAME,
            a.attname as COLUMN_NAME,
            pg_catalog.format_type(a.atttypid, a.atttypmod) as DATA_TYPE,
            '' as DATA_TYPE_MOD,
            '' as DATA_TYPE_OWNER,
            CASE WHEN 
                (SELECT substring(pg_catalog.pg_get_expr(d.adbin, d.adrelid) for 128)
                 FROM pg_catalog.pg_attrdef d
                 WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef) IS NOT NULL THEN
                      (SELECT substring(pg_catalog.pg_get_expr(d.adbin, d.adrelid) for 128)
                              FROM pg_catalog.pg_attrdef d
                              WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef)
            ELSE
                ''
            END as DATA_DEFAULT,
            CASE WHEN a.attnotnull = true THEN 
                'NOT NULL'
            ELSE
                'NULL'
            END as NULLABLE,
            a.attnum as ATTNUM,
            e.max_attnum as MAX_ATTNUM,
            '' as CHAR_USED,
            0 as DATA_PRECISION,
            0 as DATA_SCALE,
            0 as DATA_LENGTH
        FROM 
            pg_catalog.pg_attribute a
            INNER JOIN 
             (SELECT c.oid,
                n.nspname,
                c.relname
              FROM pg_catalog.pg_class c
                   LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
              WHERE c.relname = #table_name#
                AND pg_catalog.pg_table_is_visible(c.oid)
              ORDER BY 2, 3) b
            ON a.attrelid = b.oid
            INNER JOIN 
             (SELECT 
                  a.attrelid,
                  max(a.attnum) as max_attnum
              FROM pg_catalog.pg_attribute a
              WHERE a.attnum > 0 
                AND NOT a.attisdropped
              GROUP BY a.attrelid) e
            ON a.attrelid=e.attrelid
        WHERE a.attnum > 0 
          AND NOT a.attisdropped
        ORDER BY a.attnum
</select>

<!-- 
	Table DDL Script => Primary key list
 -->
<select id="getTableScript.pk" resultClass="java.util.HashMap" parameterClass="java.lang.String">
SELECT
    tc.constraint_name
    ,kcu.column_name
  FROM
    information_schema.table_constraints AS tc
      INNER JOIN information_schema.key_column_usage AS kcu
        ON tc.constraint_name = kcu.constraint_name
  WHERE
    1 = 1 AND
    tc.table_name = #table_name#
  ORDER BY
    kcu.ordinal_position
</select>

<!-- 
	Table DDL Script => Table, Column Comment Script
 -->
 
<select id="getTableScript.comments" resultClass="java.lang.String" parameterClass="java.util.HashMap">
SELECT
    'COMMENT ON TABLE ' || relname || ' IS ''' || pg_catalog.obj_description(oid,'pg_class') || '''' as "comment_text"
  FROM pg_catalog.pg_class ‌
  WHERE 1 = 1 
    AND pg_catalog.obj_description(oid,'pg_class')  > ''
    AND relkind IN ('r','')
    AND relname IN (
      SELECT a.table_name
        FROM information_schema.tables a
        WHERE a.table_schema = #schema#
          AND a.table_type = 'BASE TABLE' )
		  AND relname = #object_name#
UNION ALL
	SELECT 
		'COMMENT ON COLUMN ' ||#object_name#||'.'|| ATTNAME || ' IS ''' || pg_catalog.col_description(attrelid, attnum) || '''' 
		FROM   pg_catalog.pg_attribute
		WHERE attrelid = (select oid from pg_catalog.pg_class where relname = #object_name#) 
		AND attnum > 0 
		AND NOT attisdropped
		AND pg_catalog.col_description(attrelid, attnum) > ''
</select>

<!-- 
	Table DDL Script => All Trigger in table.
 -->
<select id="getTableScript.trigger" resultClass="java.lang.String" parameterClass="java.lang.String">
select 
    pg_get_triggerdef(t.oid) as source_text
from pg_trigger t
where t.tgrelid in (select c.oid from pg_class c where c.relname = #table_name#)
and t.tgisinternal = false
</select>

<!-- 
	Function Script 
	
	pg_get_functiondef(func_oid) : get definition of a function
 -->
 
<select id="getFunctionScript" resultClass="java.util.HashMap" parameterClass="java.util.HashMap">
 SELECT   
 	proname as procedure_name
 	, proargtypes as parameter_types
 	, prorettype as return_types
 	, prosrc as source_text
 FROM    pg_catalog.pg_namespace n   JOIN    pg_catalog.pg_proc p   ON      pronamespace = n.oid   
 WHERE   nspname = #schema#  
 and proname = #object_name#
</select>

<!-- 

 -->        
<select id="getProcedureInParamter"  resultClass="com.hangum.tadpole.engine.query.dao.rdb.InOutParameterDAO" parameterClass="java.util.HashMap">
	SELECT  proname as name, 
			proargnames as arguments,
	        oidvectortypes(proargtypes) as rdbType, 
	        t.typname as return_type,
	        prosrc as source
	FROM    pg_catalog.pg_namespace n
	JOIN    pg_catalog.pg_proc p   ON    pronamespace = n.oid     
	JOIN    pg_type t ON p.prorettype = t.oid  
	WHERE   nspname = #schema#  
		AND proname = #object_name#;
</select>
 
<!-- 
	Procedure Script 
 -->
 
<select id="getProcedureScript" resultClass="java.util.HashMap" parameterClass="java.util.HashMap">
 SELECT   
 	proname as procedure_name
 	, proargtypes as parameter_types
 	, prorettype as return_types
 	, prosrc as source_text
 FROM    pg_catalog.pg_namespace n   JOIN    pg_catalog.pg_proc p   ON      pronamespace = n.oid   
 WHERE   nspname = #schema#   
 and proname = #object_name#
</select>
 
<select id="getProcedureScript.type" resultClass="java.lang.String" parameterClass="java.lang.Object">
select typname as type_name
from pg_catalog.pg_type
where oid = #oid#;
</select>

<!-- 
	Trigger Script 
	pg_get_triggerdef(trigger_oid)	:	get CREATE [ CONSTRAINT ] TRIGGER command for trigger

<select id="getTriggerScript" resultClass="java.util.HashMap" parameterClass="java.lang.String">
select 
	trigger_name as trigger_name
	, action_timing as action_timing
	, event_manipulation as event_name
	, event_object_table as event_table
	, action_orientation as action_orientation
	, action_statement as action_statement
from information_schema.triggers
where trigger_name = #object_name#
</select>
 --> 
<select id="getTriggerScript" resultClass="java.lang.String" parameterClass="java.lang.String">
select 
    pg_get_triggerdef(t.oid) as source_text
from pg_trigger t
where t.tgname = #object_name#
</select>

<!-- 
	Index Script 
	pg_get_indexdef(index_oid)	:	get CREATE INDEX command for index
 -->
 
<select id="getIndexScript" resultClass="java.lang.String" parameterClass="java.lang.String">
select 
	indexdef as indexdef
from pg_catalog.pg_indexes
where indexname = #object_name#
</select>

<!-- 
	View Script 
	pg_get_viewdef(view_oid)	:	get underlying SELECT command for view
 -->
<select id="getViewScript.head" resultClass="java.lang.String" parameterClass="java.lang.String">
  select
  		'CREATE OR REPLACE VIEW ' || table_schema||'.'||table_name || ' AS ' AS SOURCE_TEXT
 from information_schema.views
 where table_name = #view_name#
</select> 
 
<select id="getViewScript.body" resultClass="java.lang.String" parameterClass="java.lang.String">
select 
	definition as definition
from pg_catalog.pg_views
where viewname = #object_name#
</select>

<!-- 
	SESSION LIST
 -->
<select id="sessionList" resultClass="com.hangum.tadpole.engine.query.dao.mysql.SessionListDAO">
	SELECT 
	    pid                 id,
	    application_name    pg_user,
	    datname             db,
	    client_addr || ':' || client_port     host,
	    state               state,
	    query_start         pg_time,
	    query               info
	FROM pg_stat_activity
</select>

<!-- 
	process kill
 -->
<select id="killProcess" parameterClass="java.lang.Integer">
	SELECT 
    pg_terminate_backend(#pid#) 
	FROM 
    pg_stat_activity 
</select>

</sqlMap>
